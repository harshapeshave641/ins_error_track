(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rollbar'), require('react'), require('prop-types')) :
  typeof define === 'function' && define.amd ? define(['exports', 'rollbar', 'react', 'prop-types'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Rollbar = global.Rollbar || {}, global.Rollbar.react = {}), global.Rollbar, global.React, global.PropTypes));
})(this, (function (exports, Rollbar, React, PropTypes) { 'use strict';

  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct = function () {
      return !!t;
    })();
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }

  var LEVEL_DEBUG = 'debug';
  var LEVEL_INFO = 'info';
  var LEVEL_WARN = 'warn';
  var LEVEL_ERROR = 'error';
  var LEVEL_CRITICAL = 'critical';
  var constants = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, LEVEL_DEBUG, 1), LEVEL_INFO, 2), LEVEL_WARN, 3), LEVEL_ERROR, 4), LEVEL_CRITICAL, 5);

  var isProduction = process.env.NODE_ENV === 'production';
  var prefix = 'Invariant failed';
  function invariant(condition, message) {
      if (condition) {
          return;
      }
      if (isProduction) {
          throw new Error(prefix);
      }
      var provided = typeof message === 'function' ? message() : message;
      var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
  }

  function historyContext(rollbar) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      formatter = _ref.formatter,
      filter = _ref.filter;
    invariant(rollbar instanceof Rollbar, 'historyContext must have an instance of Rollbar');
    invariant(formatter == null || typeof formatter === 'function', "formatter option must be a function, received ".concat(_typeof(formatter), " instead"));
    invariant(filter == null || typeof filter === 'function', "filter option must be a function, received ".concat(_typeof(filter), " instead"));
    // v4 of history.listen callback signature is (location, action)
    // v5 of history.listen callback signature is ({ location, action })
    // this implementation translates it to work for both
    return function (v4location, v4action) {
      var action = v4location.action,
        location = v4location.location;
      if (v4action) {
        action = v4action;
        location = v4location;
      }
      if (filter && !filter(location, action)) {
        return;
      }
      var context = formatter ? formatter(location, action) : location.pathname;
      invariant(typeof context === 'string', 'formatter must return a string value to set the context');
      rollbar.configure({
        payload: {
          context: context
        }
      });
    };
  }

  var VALID_LEVELS = constants;
  function value(val, defaultTo) {
    if (typeof val === 'function') {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return val.apply(void 0, args);
    }
    return val;
  }
  function isValidLevel(level) {
    return VALID_LEVELS[level] >= VALID_LEVELS[LEVEL_DEBUG] && VALID_LEVELS[level] <= VALID_LEVELS[LEVEL_CRITICAL];
  }
  function isRollbarInstance(instance) {
    var _instance$options;
    return !!(instance !== null && instance !== void 0 && (_instance$options = instance.options) !== null && _instance$options !== void 0 && _instance$options.accessToken);
  }

  var Context = /*#__PURE__*/React.createContext();
  Context.displayName = 'Rollbar';
  var RollbarInstance = Symbol('RollbarInstance');
  var BaseOptions = Symbol('BaseOptions');
  var RollbarCtor = Symbol('RollbarCtor');
  function getRollbarFromContext(context) {
    var rollbar = context[RollbarInstance];
    return rollbar;
  }
  var Provider = /*#__PURE__*/function (_Component) {
    _inherits(Provider, _Component);
    function Provider(props) {
      var _this;
      _classCallCheck(this, Provider);
      _this = _callSuper(this, Provider, [props]);
      var _this$props = _this.props,
        config = _this$props.config,
        _this$props$Rollbar = _this$props.Rollbar,
        ctor = _this$props$Rollbar === void 0 ? Rollbar : _this$props$Rollbar,
        instance = _this$props.instance;
      invariant(!instance || isRollbarInstance(instance), '`instance` must be a configured instance of Rollbar');
      var options = typeof config === 'function' ? config() : config;
      var rollbar = instance || new ctor(options);
      // TODO: use isUncaught to filter if this is 2nd Provider added
      // unless customer wants that
      _this.state = {
        rollbar: rollbar,
        options: options
      };
      return _this;
    }

    // componentDidUpdate()
    _createClass(Provider, [{
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
          children = _this$props2.children,
          _this$props2$Rollbar = _this$props2.Rollbar,
          ctor = _this$props2$Rollbar === void 0 ? Rollbar : _this$props2$Rollbar;
        var _this$state = this.state,
          rollbar = _this$state.rollbar,
          options = _this$state.options;
        return /*#__PURE__*/React.createElement(Context.Provider, {
          value: _defineProperty(_defineProperty(_defineProperty({}, RollbarInstance, rollbar), BaseOptions, options), RollbarCtor, ctor)
        }, children);
      }
    }]);
    return Provider;
  }(React.Component);
  _defineProperty(Provider, "propTypes", {
    Rollbar: PropTypes.func,
    config: function config(props, propName, componentName) {
      if (!props.config && !props.instance) {
        return new Error("One of the required props 'config' or 'instance' must be set for ".concat(componentName, "."));
      }
      if (props.config) {
        var configType = _typeof(props.config);
        if (configType === 'function' || configType === 'object' && !Array.isArray(configType)) {
          return;
        }
        return new Error("".concat(propName, " must be either an Object or a Function"));
      }
    },
    instance: function instance(props, propName, componentName) {
      if (!props.config && !props.instance) {
        return new Error("One of the required props 'config' or 'instance' must be set for ".concat(componentName, "."));
      }
      if (props.instance && !isRollbarInstance(props.instance)) {
        return new Error("".concat(propName, " must be a configured instance of Rollbar"));
      }
    },
    children: PropTypes.node
  });

  var INITIAL_ERROR_STATE = {
    hasError: false,
    error: null
  };
  var ErrorBoundary = /*#__PURE__*/function (_Component) {
    _inherits(ErrorBoundary, _Component);
    function ErrorBoundary(props) {
      var _this;
      _classCallCheck(this, ErrorBoundary);
      _this = _callSuper(this, ErrorBoundary, [props]);
      _defineProperty(_assertThisInitialized(_this), "resetError", function () {
        _this.setState(INITIAL_ERROR_STATE);
      });
      invariant(isValidLevel(props.level), "".concat(props.level, " is not a valid level setting for Rollbar"));
      _this.state = _objectSpread2({}, INITIAL_ERROR_STATE);
      return _this;
    }
    _createClass(ErrorBoundary, [{
      key: "componentDidCatch",
      value: function componentDidCatch(error, info) {
        var _this$props = this.props,
          errorMessage = _this$props.errorMessage,
          extra = _this$props.extra,
          targetLevel = _this$props.level,
          callback = _this$props.callback;
        var custom = value(extra, {}, error, info);
        var data = _objectSpread2(_objectSpread2({}, info), custom);
        var level = value(targetLevel, LEVEL_ERROR, error, info);
        var rollbar = getRollbarFromContext(this.context);
        if (!errorMessage) {
          rollbar[level](error, data, callback);
        } else {
          var logMessage = value(errorMessage, '', error, info);
          rollbar[level](logMessage, error, data, callback);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$state = this.state,
          hasError = _this$state.hasError,
          error = _this$state.error;
        var _this$props2 = this.props,
          FallbackUI = _this$props2.fallbackUI,
          children = _this$props2.children;
        if (!hasError) {
          return children;
        }
        if (!FallbackUI) {
          return null;
        }
        return /*#__PURE__*/React.createElement(FallbackUI, {
          error: error,
          resetError: this.resetError
        });
      }
    }], [{
      key: "getDerivedStateFromError",
      value: function getDerivedStateFromError(error) {
        return {
          hasError: true,
          error: error
        };
      }
    }]);
    return ErrorBoundary;
  }(React.Component);
  _defineProperty(ErrorBoundary, "contextType", Context);
  _defineProperty(ErrorBoundary, "propTypes", {
    fallbackUI: PropTypes.elementType,
    errorMessage: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    extra: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
    level: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
    callback: PropTypes.func,
    children: PropTypes.node
  });
  _defineProperty(ErrorBoundary, "defaultProps", {
    level: LEVEL_ERROR
  });

  var RollbarContext = /*#__PURE__*/function (_Component) {
    _inherits(RollbarContext, _Component);
    function RollbarContext(props) {
      var _this;
      _classCallCheck(this, RollbarContext);
      _this = _callSuper(this, RollbarContext, [props]);
      _defineProperty(_assertThisInitialized(_this), "firstRender", true);
      _defineProperty(_assertThisInitialized(_this), "changeContext", function () {
        var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var rollbar = getRollbarFromContext(_this.context);
        var context = _this.props.context;
        if (storePrevious) {
          _this.setState({
            previousContext: rollbar.options.payload.context
          });
        }
        rollbar.configure({
          payload: {
            context: context
          }
        });
      });
      _this.state = {
        previousContext: null
      };
      return _this;
    }
    _createClass(RollbarContext, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var onRender = this.props.onRender;
        if (!onRender) {
          this.changeContext(true);
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var onRender = this.props.onRender;
        if (!onRender) {
          this.changeContext(false);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var rollbar = getRollbarFromContext(this.context);
        var previousContext = this.state.previousContext;
        rollbar.configure({
          payload: {
            context: previousContext
          }
        });
      }
    }, {
      key: "render",
      value: function render() {
        var onRender = this.props.onRender;
        if (onRender && this.firstRender) {
          this.changeContext(true);
        }
        this.firstRender = false;
        return this.props.children;
      }
    }]);
    return RollbarContext;
  }(React.Component);
  _defineProperty(RollbarContext, "propTypes", {
    context: PropTypes.string.isRequired,
    onRender: PropTypes.bool,
    children: PropTypes.node
  });
  _defineProperty(RollbarContext, "defaultProps", {
    onRender: false
  });
  _defineProperty(RollbarContext, "contextType", Context);

  function useRollbar() {
    var context = React.useContext(Context);
    return getRollbarFromContext(context);
  }

  function useRollbarConfiguration(config) {
    var rollbar = useRollbar();
    rollbar.configure(config);
  }

  // Simple version does its job
  // export function useRollbarContext(context) {
  //   useRollbarConfiguration({ payload: { context }});
  // }

  // Complex version will set the context when part of the tree and reset back to original context when removed
  function useRollbarContext() {
    var ctx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var isLayout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    invariant(typeof ctx === 'string', '`ctx` must be a string');
    var rollbar = useRollbar();
    (isLayout ? React.useLayoutEffect : React.useEffect)(function () {
      var origCtx = rollbar.options.payload.context;
      rollbar.configure({
        payload: {
          context: ctx
        }
      });
      return function () {
        rollbar.configure({
          payload: {
            context: origCtx
          }
        });
      };
    }, [ctx]);
  }

  function useRollbarPerson(person) {
    useRollbarConfiguration({
      payload: {
        person: person
      }
    });
  }

  function useRollbarCaptureEvent(metadata) {
    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LEVEL_INFO;
    invariant(isValidLevel(level), "".concat(level, " is not a valid level setting for Rollbar"));
    var rollbar = useRollbar();
    React.useEffect(function () {
      rollbar.captureEvent(metadata, level);
    }, [metadata, level, rollbar]);
  }

  exports.Context = Context;
  exports.ErrorBoundary = ErrorBoundary;
  exports.LEVEL_CRITICAL = LEVEL_CRITICAL;
  exports.LEVEL_DEBUG = LEVEL_DEBUG;
  exports.LEVEL_ERROR = LEVEL_ERROR;
  exports.LEVEL_INFO = LEVEL_INFO;
  exports.LEVEL_WARN = LEVEL_WARN;
  exports.Provider = Provider;
  exports.RollbarContext = RollbarContext;
  exports.getRollbarFromContext = getRollbarFromContext;
  exports.historyContext = historyContext;
  exports.isValidLevel = isValidLevel;
  exports.useRollbar = useRollbar;
  exports.useRollbarCaptureEvent = useRollbarCaptureEvent;
  exports.useRollbarConfiguration = useRollbarConfiguration;
  exports.useRollbarContext = useRollbarContext;
  exports.useRollbarPerson = useRollbarPerson;

}));
//# sourceMappingURL=browser.umd.js.map
